   1               		.file	"matrix.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.matrix_init_user,"ax",@progbits
  11               		.weak	matrix_init_user
  13               	matrix_init_user:
  14               	.LFB10:
  15               		.file 1 "quantum/matrix.c"
   1:quantum/matrix.c **** /*
   2:quantum/matrix.c **** Copyright 2012 Jun Wako
   3:quantum/matrix.c **** Copyright 2014 Jack Humbert
   4:quantum/matrix.c **** 
   5:quantum/matrix.c **** This program is free software: you can redistribute it and/or modify
   6:quantum/matrix.c **** it under the terms of the GNU General Public License as published by
   7:quantum/matrix.c **** the Free Software Foundation, either version 2 of the License, or
   8:quantum/matrix.c **** (at your option) any later version.
   9:quantum/matrix.c **** 
  10:quantum/matrix.c **** This program is distributed in the hope that it will be useful,
  11:quantum/matrix.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  12:quantum/matrix.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  13:quantum/matrix.c **** GNU General Public License for more details.
  14:quantum/matrix.c **** 
  15:quantum/matrix.c **** You should have received a copy of the GNU General Public License
  16:quantum/matrix.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  17:quantum/matrix.c **** */
  18:quantum/matrix.c **** #include <stdint.h>
  19:quantum/matrix.c **** #include <stdbool.h>
  20:quantum/matrix.c **** #if defined(__AVR__)
  21:quantum/matrix.c **** #include <avr/io.h>
  22:quantum/matrix.c **** #endif
  23:quantum/matrix.c **** #include "wait.h"
  24:quantum/matrix.c **** #include "print.h"
  25:quantum/matrix.c **** #include "debug.h"
  26:quantum/matrix.c **** #include "util.h"
  27:quantum/matrix.c **** #include "matrix.h"
  28:quantum/matrix.c **** #include "timer.h"
  29:quantum/matrix.c **** 
  30:quantum/matrix.c **** 
  31:quantum/matrix.c **** /* Set 0 if debouncing isn't needed */
  32:quantum/matrix.c **** 
  33:quantum/matrix.c **** #ifndef DEBOUNCING_DELAY
  34:quantum/matrix.c **** #   define DEBOUNCING_DELAY 5
  35:quantum/matrix.c **** #endif
  36:quantum/matrix.c **** 
  37:quantum/matrix.c **** #if (DEBOUNCING_DELAY > 0)
  38:quantum/matrix.c ****     static uint16_t debouncing_time;
  39:quantum/matrix.c ****     static bool debouncing = false;
  40:quantum/matrix.c **** #endif
  41:quantum/matrix.c **** 
  42:quantum/matrix.c **** #if (MATRIX_COLS <= 8)
  43:quantum/matrix.c **** #    define print_matrix_header()  print("\nr/c 01234567\n")
  44:quantum/matrix.c **** #    define print_matrix_row(row)  print_bin_reverse8(matrix_get_row(row))
  45:quantum/matrix.c **** #    define matrix_bitpop(i)       bitpop(matrix[i])
  46:quantum/matrix.c **** #    define ROW_SHIFTER ((uint8_t)1)
  47:quantum/matrix.c **** #elif (MATRIX_COLS <= 16)
  48:quantum/matrix.c **** #    define print_matrix_header()  print("\nr/c 0123456789ABCDEF\n")
  49:quantum/matrix.c **** #    define print_matrix_row(row)  print_bin_reverse16(matrix_get_row(row))
  50:quantum/matrix.c **** #    define matrix_bitpop(i)       bitpop16(matrix[i])
  51:quantum/matrix.c **** #    define ROW_SHIFTER ((uint16_t)1)
  52:quantum/matrix.c **** #elif (MATRIX_COLS <= 32)
  53:quantum/matrix.c **** #    define print_matrix_header()  print("\nr/c 0123456789ABCDEF0123456789ABCDEF\n")
  54:quantum/matrix.c **** #    define print_matrix_row(row)  print_bin_reverse32(matrix_get_row(row))
  55:quantum/matrix.c **** #    define matrix_bitpop(i)       bitpop32(matrix[i])
  56:quantum/matrix.c **** #    define ROW_SHIFTER  ((uint32_t)1)
  57:quantum/matrix.c **** #endif
  58:quantum/matrix.c **** 
  59:quantum/matrix.c **** #ifdef MATRIX_MASKED
  60:quantum/matrix.c ****     extern const matrix_row_t matrix_mask[];
  61:quantum/matrix.c **** #endif
  62:quantum/matrix.c **** 
  63:quantum/matrix.c **** static const uint8_t row_pins[MATRIX_ROWS] = MATRIX_ROW_PINS;
  64:quantum/matrix.c **** static const uint8_t col_pins[MATRIX_COLS] = MATRIX_COL_PINS;
  65:quantum/matrix.c **** 
  66:quantum/matrix.c **** /* matrix state(1:on, 0:off) */
  67:quantum/matrix.c **** static matrix_row_t matrix[MATRIX_ROWS];
  68:quantum/matrix.c **** 
  69:quantum/matrix.c **** static matrix_row_t matrix_raw[MATRIX_ROWS];
  70:quantum/matrix.c **** static matrix_row_t matrix_debouncing[MATRIX_ROWS];
  71:quantum/matrix.c **** 
  72:quantum/matrix.c **** 
  73:quantum/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
  74:quantum/matrix.c ****     static void init_cols(void);
  75:quantum/matrix.c ****     static bool read_cols_on_row(matrix_row_t current_matrix[], uint8_t current_row);
  76:quantum/matrix.c ****     static void unselect_rows(void);
  77:quantum/matrix.c ****     static void select_row(uint8_t row);
  78:quantum/matrix.c ****     static void unselect_row(uint8_t row);
  79:quantum/matrix.c **** #else // ROW2COL
  80:quantum/matrix.c ****     static void init_rows(void);
  81:quantum/matrix.c ****     static bool read_rows_on_col(matrix_row_t current_matrix[], uint8_t current_col);
  82:quantum/matrix.c ****     static void unselect_cols(void);
  83:quantum/matrix.c ****     static void unselect_col(uint8_t col);
  84:quantum/matrix.c ****     static void select_col(uint8_t col);
  85:quantum/matrix.c **** #endif
  86:quantum/matrix.c **** 
  87:quantum/matrix.c **** __attribute__ ((weak))
  88:quantum/matrix.c **** void matrix_init_quantum(void) {
  89:quantum/matrix.c ****     matrix_init_kb();
  90:quantum/matrix.c **** }
  91:quantum/matrix.c **** 
  92:quantum/matrix.c **** __attribute__ ((weak))
  93:quantum/matrix.c **** void matrix_scan_quantum(void) {
  94:quantum/matrix.c ****     matrix_scan_kb();
  95:quantum/matrix.c **** }
  96:quantum/matrix.c **** 
  97:quantum/matrix.c **** __attribute__ ((weak))
  98:quantum/matrix.c **** void matrix_init_kb(void) {
  99:quantum/matrix.c ****     matrix_init_user();
 100:quantum/matrix.c **** }
 101:quantum/matrix.c **** 
 102:quantum/matrix.c **** __attribute__ ((weak))
 103:quantum/matrix.c **** void matrix_scan_kb(void) {
 104:quantum/matrix.c ****     matrix_scan_user();
 105:quantum/matrix.c **** }
 106:quantum/matrix.c **** 
 107:quantum/matrix.c **** __attribute__ ((weak))
 108:quantum/matrix.c **** void matrix_init_user(void) {
  16               		.loc 1 108 29 view -0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
 109:quantum/matrix.c **** }
  22               		.loc 1 109 1 view .LVU1
  23               	/* epilogue start */
  24 0000 0895      		ret
  25               		.cfi_endproc
  26               	.LFE10:
  28               		.set	matrix_init_user.localalias,matrix_init_user
  29               		.section	.text.matrix_init_kb,"ax",@progbits
  30               		.weak	matrix_init_kb
  32               	matrix_init_kb:
  33               	.LFB8:
  98:quantum/matrix.c ****     matrix_init_user();
  34               		.loc 1 98 27 view -0
  35               		.cfi_startproc
  36               	/* prologue: function */
  37               	/* frame size = 0 */
  38               	/* stack size = 0 */
  39               	.L__stack_usage = 0
  99:quantum/matrix.c **** }
  40               		.loc 1 99 5 view .LVU3
  41 0000 0C94 0000 		jmp matrix_init_user
  42               	.LVL0:
  43               		.cfi_endproc
  44               	.LFE8:
  46               		.section	.text.matrix_init_quantum,"ax",@progbits
  47               		.weak	matrix_init_quantum
  49               	matrix_init_quantum:
  50               	.LFB6:
  88:quantum/matrix.c ****     matrix_init_kb();
  51               		.loc 1 88 32 view -0
  52               		.cfi_startproc
  53               	/* prologue: function */
  54               	/* frame size = 0 */
  55               	/* stack size = 0 */
  56               	.L__stack_usage = 0
  89:quantum/matrix.c **** }
  57               		.loc 1 89 5 view .LVU5
  58 0000 0C94 0000 		jmp matrix_init_kb
  59               	.LVL1:
  60               		.cfi_endproc
  61               	.LFE6:
  63               		.section	.text.matrix_scan_user,"ax",@progbits
  64               		.weak	matrix_scan_user
  66               	matrix_scan_user:
  67               	.LFB27:
  68               		.cfi_startproc
  69               	/* prologue: function */
  70               	/* frame size = 0 */
  71               	/* stack size = 0 */
  72               	.L__stack_usage = 0
  73               	/* epilogue start */
  74 0000 0895      		ret
  75               		.cfi_endproc
  76               	.LFE27:
  78               		.section	.text.matrix_scan_kb,"ax",@progbits
  79               		.weak	matrix_scan_kb
  81               	matrix_scan_kb:
  82               	.LFB9:
 103:quantum/matrix.c ****     matrix_scan_user();
  83               		.loc 1 103 27 view -0
  84               		.cfi_startproc
  85               	/* prologue: function */
  86               	/* frame size = 0 */
  87               	/* stack size = 0 */
  88               	.L__stack_usage = 0
 104:quantum/matrix.c **** }
  89               		.loc 1 104 5 view .LVU7
  90 0000 0C94 0000 		jmp matrix_scan_user
  91               	.LVL2:
  92               		.cfi_endproc
  93               	.LFE9:
  95               		.section	.text.matrix_scan_quantum,"ax",@progbits
  96               		.weak	matrix_scan_quantum
  98               	matrix_scan_quantum:
  99               	.LFB7:
  93:quantum/matrix.c ****     matrix_scan_kb();
 100               		.loc 1 93 32 view -0
 101               		.cfi_startproc
 102               	/* prologue: function */
 103               	/* frame size = 0 */
 104               	/* stack size = 0 */
 105               	.L__stack_usage = 0
  94:quantum/matrix.c **** }
 106               		.loc 1 94 5 view .LVU9
 107 0000 0C94 0000 		jmp matrix_scan_kb
 108               	.LVL3:
 109               		.cfi_endproc
 110               	.LFE7:
 112               		.section	.text.matrix_rows,"ax",@progbits
 113               	.global	matrix_rows
 115               	matrix_rows:
 116               	.LFB12:
 110:quantum/matrix.c **** 
 111:quantum/matrix.c **** __attribute__ ((weak))
 112:quantum/matrix.c **** void matrix_scan_user(void) {
 113:quantum/matrix.c **** }
 114:quantum/matrix.c **** 
 115:quantum/matrix.c **** inline
 116:quantum/matrix.c **** uint8_t matrix_rows(void) {
 117               		.loc 1 116 27 view -0
 118               		.cfi_startproc
 119               	/* prologue: function */
 120               	/* frame size = 0 */
 121               	/* stack size = 0 */
 122               	.L__stack_usage = 0
 117:quantum/matrix.c ****     return MATRIX_ROWS;
 123               		.loc 1 117 5 view .LVU11
 118:quantum/matrix.c **** }
 124               		.loc 1 118 1 is_stmt 0 view .LVU12
 125 0000 81E0      		ldi r24,lo8(1)
 126               	/* epilogue start */
 127 0002 0895      		ret
 128               		.cfi_endproc
 129               	.LFE12:
 131               		.section	.text.matrix_cols,"ax",@progbits
 132               	.global	matrix_cols
 134               	matrix_cols:
 135               	.LFB13:
 119:quantum/matrix.c **** 
 120:quantum/matrix.c **** inline
 121:quantum/matrix.c **** uint8_t matrix_cols(void) {
 136               		.loc 1 121 27 is_stmt 1 view -0
 137               		.cfi_startproc
 138               	/* prologue: function */
 139               	/* frame size = 0 */
 140               	/* stack size = 0 */
 141               	.L__stack_usage = 0
 122:quantum/matrix.c ****     return MATRIX_COLS;
 142               		.loc 1 122 5 view .LVU14
 123:quantum/matrix.c **** }
 143               		.loc 1 123 1 is_stmt 0 view .LVU15
 144 0000 83E0      		ldi r24,lo8(3)
 145               	/* epilogue start */
 146 0002 0895      		ret
 147               		.cfi_endproc
 148               	.LFE13:
 150               		.section	.text.matrix_init,"ax",@progbits
 151               	.global	matrix_init
 153               	matrix_init:
 154               	.LFB14:
 124:quantum/matrix.c **** 
 125:quantum/matrix.c **** // void matrix_power_up(void) {
 126:quantum/matrix.c **** // #if (DIODE_DIRECTION == COL2ROW)
 127:quantum/matrix.c **** //     for (int8_t r = MATRIX_ROWS - 1; r >= 0; --r) {
 128:quantum/matrix.c **** //         /* DDRxn */
 129:quantum/matrix.c **** //         _SFR_IO8((row_pins[r] >> 4) + 1) |= _BV(row_pins[r] & 0xF);
 130:quantum/matrix.c **** //         toggle_row(r);
 131:quantum/matrix.c **** //     }
 132:quantum/matrix.c **** //     for (int8_t c = MATRIX_COLS - 1; c >= 0; --c) {
 133:quantum/matrix.c **** //         /* PORTxn */
 134:quantum/matrix.c **** //         _SFR_IO8((col_pins[c] >> 4) + 2) |= _BV(col_pins[c] & 0xF);
 135:quantum/matrix.c **** //     }
 136:quantum/matrix.c **** // #else
 137:quantum/matrix.c **** //     for (int8_t c = MATRIX_COLS - 1; c >= 0; --c) {
 138:quantum/matrix.c **** //         /* DDRxn */
 139:quantum/matrix.c **** //         _SFR_IO8((col_pins[c] >> 4) + 1) |= _BV(col_pins[c] & 0xF);
 140:quantum/matrix.c **** //         toggle_col(c);
 141:quantum/matrix.c **** //     }
 142:quantum/matrix.c **** //     for (int8_t r = MATRIX_ROWS - 1; r >= 0; --r) {
 143:quantum/matrix.c **** //         /* PORTxn */
 144:quantum/matrix.c **** //         _SFR_IO8((row_pins[r] >> 4) + 2) |= _BV(row_pins[r] & 0xF);
 145:quantum/matrix.c **** //     }
 146:quantum/matrix.c **** // #endif
 147:quantum/matrix.c **** // }
 148:quantum/matrix.c **** 
 149:quantum/matrix.c **** void matrix_init(void) {
 155               		.loc 1 149 24 is_stmt 1 view -0
 156               		.cfi_startproc
 157 0000 CF93      		push r28
 158               	.LCFI0:
 159               		.cfi_def_cfa_offset 3
 160               		.cfi_offset 28, -2
 161 0002 DF93      		push r29
 162               	.LCFI1:
 163               		.cfi_def_cfa_offset 4
 164               		.cfi_offset 29, -3
 165               	/* prologue: function */
 166               	/* frame size = 0 */
 167               	/* stack size = 2 */
 168               	.L__stack_usage = 2
 150:quantum/matrix.c **** 
 151:quantum/matrix.c ****     // To use PORTF disable JTAG with writing JTD bit twice within four cycles.
 152:quantum/matrix.c ****     #if  (defined(__AVR_AT90USB1286__) || defined(__AVR_AT90USB1287__) || defined(__AVR_ATmega32U4_
 153:quantum/matrix.c ****         MCUCR |= _BV(JTD);
 169               		.loc 1 153 9 view .LVU17
 170               		.loc 1 153 15 is_stmt 0 view .LVU18
 171 0004 85B7      		in r24,0x35
 172 0006 8068      		ori r24,lo8(-128)
 173 0008 85BF      		out 0x35,r24
 154:quantum/matrix.c ****         MCUCR |= _BV(JTD);
 174               		.loc 1 154 9 is_stmt 1 view .LVU19
 175               		.loc 1 154 15 is_stmt 0 view .LVU20
 176 000a 85B7      		in r24,0x35
 177 000c 8068      		ori r24,lo8(-128)
 178 000e 85BF      		out 0x35,r24
 155:quantum/matrix.c ****     #endif
 156:quantum/matrix.c **** 
 157:quantum/matrix.c ****     // initialize row and col
 158:quantum/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
 159:quantum/matrix.c ****     unselect_rows();
 160:quantum/matrix.c ****     init_cols();
 161:quantum/matrix.c **** #else // ROW2COL
 162:quantum/matrix.c ****     unselect_cols();
 179               		.loc 1 162 5 is_stmt 1 view .LVU21
 180               	.LBB19:
 181               	.LBI19:
 163:quantum/matrix.c ****     init_rows();
 164:quantum/matrix.c **** #endif
 165:quantum/matrix.c **** 
 166:quantum/matrix.c ****     // initialize matrix state: all keys off
 167:quantum/matrix.c ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
 168:quantum/matrix.c ****         matrix[i] = 0;
 169:quantum/matrix.c ****         matrix_raw[i] = 0;
 170:quantum/matrix.c ****         matrix_debouncing[i] = 0;
 171:quantum/matrix.c ****     }
 172:quantum/matrix.c **** 
 173:quantum/matrix.c ****     matrix_init_quantum();
 174:quantum/matrix.c **** }
 175:quantum/matrix.c **** 
 176:quantum/matrix.c **** uint8_t matrix_scan(void)
 177:quantum/matrix.c **** {
 178:quantum/matrix.c **** 
 179:quantum/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
 180:quantum/matrix.c **** 
 181:quantum/matrix.c ****     // Set row, read cols
 182:quantum/matrix.c ****     for (uint8_t current_row = 0; current_row < MATRIX_ROWS; current_row++) {
 183:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 184:quantum/matrix.c ****             bool matrix_changed = read_cols_on_row(matrix_debouncing, current_row);
 185:quantum/matrix.c **** 
 186:quantum/matrix.c ****             if (matrix_changed) {
 187:quantum/matrix.c ****                 debouncing = true;
 188:quantum/matrix.c ****                 debouncing_time = timer_read();
 189:quantum/matrix.c ****             }
 190:quantum/matrix.c **** 
 191:quantum/matrix.c **** #       else
 192:quantum/matrix.c ****             read_cols_on_row(matrix, current_row);
 193:quantum/matrix.c **** #       endif
 194:quantum/matrix.c **** 
 195:quantum/matrix.c ****     }
 196:quantum/matrix.c **** 
 197:quantum/matrix.c **** #else // ROW2COL
 198:quantum/matrix.c **** 
 199:quantum/matrix.c ****     // Set col, read rows
 200:quantum/matrix.c ****     for (uint8_t current_col = 0; current_col < MATRIX_COLS; current_col++) {
 201:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 202:quantum/matrix.c ****             bool matrix_changed = read_rows_on_col(matrix_debouncing, current_col);
 203:quantum/matrix.c ****             if (matrix_changed) {
 204:quantum/matrix.c ****                 debouncing = true;
 205:quantum/matrix.c ****                 debouncing_time = timer_read();
 206:quantum/matrix.c ****             }
 207:quantum/matrix.c **** #       else
 208:quantum/matrix.c ****              read_rows_on_col(matrix, current_col);
 209:quantum/matrix.c **** #       endif
 210:quantum/matrix.c **** 
 211:quantum/matrix.c ****     }
 212:quantum/matrix.c **** 
 213:quantum/matrix.c **** #endif
 214:quantum/matrix.c **** 
 215:quantum/matrix.c **** #   if (DEBOUNCING_DELAY > 0)
 216:quantum/matrix.c ****         if (debouncing && (timer_elapsed(debouncing_time) > DEBOUNCING_DELAY)) {
 217:quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 218:quantum/matrix.c ****                 matrix[i] = matrix_debouncing[i];
 219:quantum/matrix.c ****             }
 220:quantum/matrix.c ****             debouncing = false;
 221:quantum/matrix.c ****         }
 222:quantum/matrix.c **** #   endif
 223:quantum/matrix.c **** 
 224:quantum/matrix.c ****     matrix_scan_quantum();
 225:quantum/matrix.c ****     return 1;
 226:quantum/matrix.c **** }
 227:quantum/matrix.c **** 
 228:quantum/matrix.c **** bool matrix_is_modified(void)
 229:quantum/matrix.c **** {
 230:quantum/matrix.c **** #if (DEBOUNCING_DELAY > 0)
 231:quantum/matrix.c ****     if (debouncing) return false;
 232:quantum/matrix.c **** #endif
 233:quantum/matrix.c ****     return true;
 234:quantum/matrix.c **** }
 235:quantum/matrix.c **** 
 236:quantum/matrix.c **** inline
 237:quantum/matrix.c **** bool matrix_is_on(uint8_t row, uint8_t col)
 238:quantum/matrix.c **** {
 239:quantum/matrix.c ****     return (matrix[row] & ((matrix_row_t)1<col));
 240:quantum/matrix.c **** }
 241:quantum/matrix.c **** 
 242:quantum/matrix.c **** inline
 243:quantum/matrix.c **** matrix_row_t matrix_get_row(uint8_t row)
 244:quantum/matrix.c **** {
 245:quantum/matrix.c ****     // Matrix mask lets you disable switches in the returned matrix data. For example, if you have 
 246:quantum/matrix.c ****     // switch blocker installed and the switch is always pressed.
 247:quantum/matrix.c **** #ifdef MATRIX_MASKED
 248:quantum/matrix.c ****     return matrix[row] & matrix_mask[row];
 249:quantum/matrix.c **** #else
 250:quantum/matrix.c ****     return matrix[row];
 251:quantum/matrix.c **** #endif
 252:quantum/matrix.c **** }
 253:quantum/matrix.c **** 
 254:quantum/matrix.c **** void matrix_print(void)
 255:quantum/matrix.c **** {
 256:quantum/matrix.c ****     print_matrix_header();
 257:quantum/matrix.c **** 
 258:quantum/matrix.c ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
 259:quantum/matrix.c ****         phex(row); print(": ");
 260:quantum/matrix.c ****         print_matrix_row(row);
 261:quantum/matrix.c ****         print("\n");
 262:quantum/matrix.c ****     }
 263:quantum/matrix.c **** }
 264:quantum/matrix.c **** 
 265:quantum/matrix.c **** uint8_t matrix_key_count(void)
 266:quantum/matrix.c **** {
 267:quantum/matrix.c ****     uint8_t count = 0;
 268:quantum/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 269:quantum/matrix.c ****         count += matrix_bitpop(i);
 270:quantum/matrix.c ****     }
 271:quantum/matrix.c ****     return count;
 272:quantum/matrix.c **** }
 273:quantum/matrix.c **** 
 274:quantum/matrix.c **** 
 275:quantum/matrix.c **** 
 276:quantum/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
 277:quantum/matrix.c **** 
 278:quantum/matrix.c **** static void init_cols(void)
 279:quantum/matrix.c **** {
 280:quantum/matrix.c ****     for(uint8_t x = 0; x < MATRIX_COLS; x++) {
 281:quantum/matrix.c ****         uint8_t pin = col_pins[x];
 282:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 283:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 284:quantum/matrix.c ****     }
 285:quantum/matrix.c **** }
 286:quantum/matrix.c **** 
 287:quantum/matrix.c **** static bool read_cols_on_row(matrix_row_t current_matrix[], uint8_t current_row)
 288:quantum/matrix.c **** {
 289:quantum/matrix.c ****     // Store last value of row prior to reading
 290:quantum/matrix.c ****     matrix_row_t last_row_value = current_matrix[current_row];
 291:quantum/matrix.c **** 
 292:quantum/matrix.c ****     // Clear data in matrix row
 293:quantum/matrix.c ****     current_matrix[current_row] = 0;
 294:quantum/matrix.c **** 
 295:quantum/matrix.c ****     // Select row and wait for row selecton to stabilize
 296:quantum/matrix.c ****     select_row(current_row);
 297:quantum/matrix.c ****     wait_us(30);
 298:quantum/matrix.c **** 
 299:quantum/matrix.c ****     // For each col...
 300:quantum/matrix.c ****     for(uint8_t col_index = 0; col_index < MATRIX_COLS; col_index++) {
 301:quantum/matrix.c **** 
 302:quantum/matrix.c ****         // Select the col pin to read (active low)
 303:quantum/matrix.c ****         uint8_t pin = col_pins[col_index];
 304:quantum/matrix.c ****         uint8_t pin_state = (_SFR_IO8(pin >> 4) & _BV(pin & 0xF));
 305:quantum/matrix.c **** 
 306:quantum/matrix.c ****         // Populate the matrix row with the state of the col pin
 307:quantum/matrix.c ****         current_matrix[current_row] |=  pin_state ? 0 : (ROW_SHIFTER << col_index);
 308:quantum/matrix.c ****     }
 309:quantum/matrix.c **** 
 310:quantum/matrix.c ****     // Unselect row
 311:quantum/matrix.c ****     unselect_row(current_row);
 312:quantum/matrix.c **** 
 313:quantum/matrix.c ****     return (last_row_value != current_matrix[current_row]);
 314:quantum/matrix.c **** }
 315:quantum/matrix.c **** 
 316:quantum/matrix.c **** static void select_row(uint8_t row)
 317:quantum/matrix.c **** {
 318:quantum/matrix.c ****     uint8_t pin = row_pins[row];
 319:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) |=  _BV(pin & 0xF); // OUT
 320:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 321:quantum/matrix.c **** }
 322:quantum/matrix.c **** 
 323:quantum/matrix.c **** static void unselect_row(uint8_t row)
 324:quantum/matrix.c **** {
 325:quantum/matrix.c ****     uint8_t pin = row_pins[row];
 326:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 327:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 328:quantum/matrix.c **** }
 329:quantum/matrix.c **** 
 330:quantum/matrix.c **** static void unselect_rows(void)
 331:quantum/matrix.c **** {
 332:quantum/matrix.c ****     for(uint8_t x = 0; x < MATRIX_ROWS; x++) {
 333:quantum/matrix.c ****         uint8_t pin = row_pins[x];
 334:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 335:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 336:quantum/matrix.c ****     }
 337:quantum/matrix.c **** }
 338:quantum/matrix.c **** 
 339:quantum/matrix.c **** #else // ROW2COL
 340:quantum/matrix.c **** 
 341:quantum/matrix.c **** static void init_rows(void)
 342:quantum/matrix.c **** {
 343:quantum/matrix.c ****     for(uint8_t x = 0; x < MATRIX_ROWS; x++) {
 344:quantum/matrix.c ****         uint8_t pin = row_pins[x];
 345:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 346:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 347:quantum/matrix.c ****     }
 348:quantum/matrix.c **** }
 349:quantum/matrix.c **** 
 350:quantum/matrix.c **** static bool read_rows_on_col(matrix_row_t current_matrix[], uint8_t current_col)
 351:quantum/matrix.c **** {
 352:quantum/matrix.c ****     bool matrix_changed = false;
 353:quantum/matrix.c **** 
 354:quantum/matrix.c ****     // Select col and wait for col selecton to stabilize
 355:quantum/matrix.c ****     select_col(current_col);
 356:quantum/matrix.c ****     wait_us(30);
 357:quantum/matrix.c **** 
 358:quantum/matrix.c ****     // For each row...
 359:quantum/matrix.c ****     for(uint8_t row_index = 0; row_index < MATRIX_ROWS; row_index++)
 360:quantum/matrix.c ****     {
 361:quantum/matrix.c **** 
 362:quantum/matrix.c ****         // Store last value of row prior to reading
 363:quantum/matrix.c ****         matrix_row_t last_row_value = current_matrix[row_index];
 364:quantum/matrix.c **** 
 365:quantum/matrix.c ****         // Check row pin state
 366:quantum/matrix.c ****         if ((_SFR_IO8(row_pins[row_index] >> 4) & _BV(row_pins[row_index] & 0xF)) == 0)
 367:quantum/matrix.c ****         {
 368:quantum/matrix.c ****             // Pin LO, set col bit
 369:quantum/matrix.c ****             current_matrix[row_index] |= (ROW_SHIFTER << current_col);
 370:quantum/matrix.c ****         }
 371:quantum/matrix.c ****         else
 372:quantum/matrix.c ****         {
 373:quantum/matrix.c ****             // Pin HI, clear col bit
 374:quantum/matrix.c ****             current_matrix[row_index] &= ~(ROW_SHIFTER << current_col);
 375:quantum/matrix.c ****         }
 376:quantum/matrix.c **** 
 377:quantum/matrix.c ****         // Determine if the matrix changed state
 378:quantum/matrix.c ****         if ((last_row_value != current_matrix[row_index]) && !(matrix_changed))
 379:quantum/matrix.c ****         {
 380:quantum/matrix.c ****             matrix_changed = true;
 381:quantum/matrix.c ****         }
 382:quantum/matrix.c ****     }
 383:quantum/matrix.c **** 
 384:quantum/matrix.c ****     // Unselect col
 385:quantum/matrix.c ****     unselect_col(current_col);
 386:quantum/matrix.c **** 
 387:quantum/matrix.c ****     return matrix_changed;
 388:quantum/matrix.c **** }
 389:quantum/matrix.c **** 
 390:quantum/matrix.c **** static void select_col(uint8_t col)
 391:quantum/matrix.c **** {
 392:quantum/matrix.c ****     uint8_t pin = col_pins[col];
 393:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) |=  _BV(pin & 0xF); // OUT
 394:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 395:quantum/matrix.c **** }
 396:quantum/matrix.c **** 
 397:quantum/matrix.c **** static void unselect_col(uint8_t col)
 398:quantum/matrix.c **** {
 399:quantum/matrix.c ****     uint8_t pin = col_pins[col];
 400:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 401:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 402:quantum/matrix.c **** }
 403:quantum/matrix.c **** 
 404:quantum/matrix.c **** static void unselect_cols(void)
 182               		.loc 1 404 13 view .LVU22
 183               	.LBE19:
 405:quantum/matrix.c **** {
 406:quantum/matrix.c ****     for(uint8_t x = 0; x < MATRIX_COLS; x++) {
 184               		.loc 1 406 5 view .LVU23
 185               	.LBB22:
 186               	.LBB20:
 187               		.loc 1 406 9 view .LVU24
 188               	.LVL4:
 189               		.loc 1 406 24 view .LVU25
 190 0010 A0E0      		ldi r26,lo8(col_pins)
 191 0012 B0E0      		ldi r27,hi8(col_pins)
 192 0014 40E0      		ldi r20,lo8(col_pins+3)
 193 0016 50E0      		ldi r21,hi8(col_pins+3)
 194               	.LBB21:
 407:quantum/matrix.c ****         uint8_t pin = col_pins[x];
 408:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 195               		.loc 1 408 38 is_stmt 0 view .LVU26
 196 0018 C1E0      		ldi r28,lo8(1)
 197 001a D0E0      		ldi r29,0
 198               	.LVL5:
 199               	.L10:
 407:quantum/matrix.c ****         uint8_t pin = col_pins[x];
 200               		.loc 1 407 9 is_stmt 1 view .LVU27
 407:quantum/matrix.c ****         uint8_t pin = col_pins[x];
 201               		.loc 1 407 17 is_stmt 0 view .LVU28
 202 001c 8D91      		ld r24,X+
 203               	.LVL6:
 204               		.loc 1 408 9 is_stmt 1 view .LVU29
 205               		.loc 1 408 34 is_stmt 0 view .LVU30
 206 001e E82F      		mov r30,r24
 207 0020 E295      		swap r30
 208 0022 EF70      		andi r30,lo8(15)
 209 0024 F0E0      		ldi r31,0
 210 0026 61A1      		ldd r22,Z+33
 211               		.loc 1 408 38 view .LVU31
 212 0028 8F70      		andi r24,lo8(15)
 213               	.LVL7:
 214               		.loc 1 408 38 view .LVU32
 215 002a 9E01      		movw r18,r28
 216 002c 00C0      		rjmp 2f
 217               		1:
 218 002e 220F      		lsl r18
 219               		2:
 220 0030 8A95      		dec r24
 221 0032 02F4      		brpl 1b
 222               		.loc 1 408 34 view .LVU33
 223 0034 922F      		mov r25,r18
 224 0036 9095      		com r25
 225 0038 9623      		and r25,r22
 226 003a 91A3      		std Z+33,r25
 227               	.LVL8:
 409:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 228               		.loc 1 409 9 is_stmt 1 view .LVU34
 229               		.loc 1 409 34 is_stmt 0 view .LVU35
 230 003c 82A1      		ldd r24,Z+34
 231 003e 822B      		or r24,r18
 232 0040 82A3      		std Z+34,r24
 233               	.LBE21:
 406:quantum/matrix.c ****         uint8_t pin = col_pins[x];
 234               		.loc 1 406 41 is_stmt 1 view .LVU36
 235               	.LVL9:
 406:quantum/matrix.c ****         uint8_t pin = col_pins[x];
 236               		.loc 1 406 24 view .LVU37
 406:quantum/matrix.c ****         uint8_t pin = col_pins[x];
 237               		.loc 1 406 5 is_stmt 0 view .LVU38
 238 0042 4A17      		cp r20,r26
 239 0044 5B07      		cpc r21,r27
 240 0046 01F4      		brne .L10
 241               	.LVL10:
 406:quantum/matrix.c ****         uint8_t pin = col_pins[x];
 242               		.loc 1 406 5 view .LVU39
 243               	.LBE20:
 244               	.LBE22:
 245               	.LBB23:
 246               	.LBB24:
 343:quantum/matrix.c ****         uint8_t pin = row_pins[x];
 247               		.loc 1 343 24 is_stmt 1 view .LVU40
 248               	.LBB25:
 344:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 249               		.loc 1 344 9 view .LVU41
 345:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 250               		.loc 1 345 9 view .LVU42
 345:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 251               		.loc 1 345 34 is_stmt 0 view .LVU43
 252 0048 5498      		cbi 0xa,4
 346:quantum/matrix.c ****     }
 253               		.loc 1 346 9 is_stmt 1 view .LVU44
 346:quantum/matrix.c ****     }
 254               		.loc 1 346 34 is_stmt 0 view .LVU45
 255 004a 5C9A      		sbi 0xb,4
 256               	.LBE25:
 343:quantum/matrix.c ****         uint8_t pin = row_pins[x];
 257               		.loc 1 343 41 is_stmt 1 view .LVU46
 258               	.LVL11:
 343:quantum/matrix.c ****         uint8_t pin = row_pins[x];
 259               		.loc 1 343 24 view .LVU47
 343:quantum/matrix.c ****         uint8_t pin = row_pins[x];
 260               		.loc 1 343 24 is_stmt 0 view .LVU48
 261               	.LBE24:
 262               	.LBE23:
 263               	.LBB26:
 167:quantum/matrix.c ****         matrix[i] = 0;
 264               		.loc 1 167 23 is_stmt 1 view .LVU49
 168:quantum/matrix.c ****         matrix_raw[i] = 0;
 265               		.loc 1 168 9 view .LVU50
 168:quantum/matrix.c ****         matrix_raw[i] = 0;
 266               		.loc 1 168 19 is_stmt 0 view .LVU51
 267 004c 1092 0000 		sts matrix,__zero_reg__
 169:quantum/matrix.c ****         matrix_debouncing[i] = 0;
 268               		.loc 1 169 9 is_stmt 1 view .LVU52
 170:quantum/matrix.c ****     }
 269               		.loc 1 170 9 view .LVU53
 170:quantum/matrix.c ****     }
 270               		.loc 1 170 30 is_stmt 0 view .LVU54
 271 0050 1092 0000 		sts matrix_debouncing,__zero_reg__
 167:quantum/matrix.c ****         matrix[i] = 0;
 272               		.loc 1 167 40 is_stmt 1 view .LVU55
 273               	.LVL12:
 167:quantum/matrix.c ****         matrix[i] = 0;
 274               		.loc 1 167 23 view .LVU56
 275               	.LBE26:
 173:quantum/matrix.c **** }
 276               		.loc 1 173 5 view .LVU57
 277               	/* epilogue start */
 174:quantum/matrix.c **** 
 278               		.loc 1 174 1 is_stmt 0 view .LVU58
 279 0054 DF91      		pop r29
 280 0056 CF91      		pop r28
 173:quantum/matrix.c **** }
 281               		.loc 1 173 5 view .LVU59
 282 0058 0C94 0000 		jmp matrix_init_quantum
 283               	.LVL13:
 284               		.cfi_endproc
 285               	.LFE14:
 287               		.section	.text.matrix_scan,"ax",@progbits
 288               	.global	matrix_scan
 290               	matrix_scan:
 291               	.LFB15:
 177:quantum/matrix.c **** 
 292               		.loc 1 177 1 is_stmt 1 view -0
 293               		.cfi_startproc
 294 0000 DF92      		push r13
 295               	.LCFI2:
 296               		.cfi_def_cfa_offset 3
 297               		.cfi_offset 13, -2
 298 0002 EF92      		push r14
 299               	.LCFI3:
 300               		.cfi_def_cfa_offset 4
 301               		.cfi_offset 14, -3
 302 0004 FF92      		push r15
 303               	.LCFI4:
 304               		.cfi_def_cfa_offset 5
 305               		.cfi_offset 15, -4
 306 0006 0F93      		push r16
 307               	.LCFI5:
 308               		.cfi_def_cfa_offset 6
 309               		.cfi_offset 16, -5
 310 0008 1F93      		push r17
 311               	.LCFI6:
 312               		.cfi_def_cfa_offset 7
 313               		.cfi_offset 17, -6
 314 000a CF93      		push r28
 315               	.LCFI7:
 316               		.cfi_def_cfa_offset 8
 317               		.cfi_offset 28, -7
 318 000c DF93      		push r29
 319               	.LCFI8:
 320               		.cfi_def_cfa_offset 9
 321               		.cfi_offset 29, -8
 322               	/* prologue: function */
 323               	/* frame size = 0 */
 324               	/* stack size = 7 */
 325               	.L__stack_usage = 7
 200:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 326               		.loc 1 200 5 view .LVU61
 327               	.LBB40:
 200:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 328               		.loc 1 200 10 view .LVU62
 329               	.LVL14:
 200:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 330               		.loc 1 200 35 view .LVU63
 331 000e 00E0      		ldi r16,lo8(col_pins)
 332 0010 10E0      		ldi r17,hi8(col_pins)
 333               	.LBE40:
 177:quantum/matrix.c **** 
 334               		.loc 1 177 1 is_stmt 0 view .LVU64
 335 0012 D0E0      		ldi r29,0
 336 0014 C0E0      		ldi r28,0
 337               	.LBB61:
 338               	.LBB41:
 339               	.LBB42:
 340               	.LBB43:
 341               	.LBB44:
 342               	.LBB45:
 393:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 343               		.loc 1 393 34 view .LVU65
 344 0016 EE24      		clr r14
 345 0018 E394      		inc r14
 346 001a F12C      		mov r15,__zero_reg__
 347               	.LBE45:
 348               	.LBE44:
 349               	.LBE43:
 350               	.LBE42:
 204:quantum/matrix.c ****                 debouncing_time = timer_read();
 351               		.loc 1 204 28 view .LVU66
 352 001c DD24      		clr r13
 353 001e D394      		inc r13
 354               	.LVL15:
 355               	.L16:
 202:quantum/matrix.c ****             if (matrix_changed) {
 356               		.loc 1 202 13 is_stmt 1 view .LVU67
 357               	.LBB58:
 358               	.LBI42:
 350:quantum/matrix.c **** {
 359               		.loc 1 350 13 view .LVU68
 360               	.LBB56:
 352:quantum/matrix.c **** 
 361               		.loc 1 352 5 view .LVU69
 355:quantum/matrix.c ****     wait_us(30);
 362               		.loc 1 355 5 view .LVU70
 363               	.LBB47:
 364               	.LBI44:
 390:quantum/matrix.c **** {
 365               		.loc 1 390 13 view .LVU71
 366               	.LBB46:
 392:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) |=  _BV(pin & 0xF); // OUT
 367               		.loc 1 392 5 view .LVU72
 392:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) |=  _BV(pin & 0xF); // OUT
 368               		.loc 1 392 13 is_stmt 0 view .LVU73
 369 0020 F801      		movw r30,r16
 370 0022 8191      		ld r24,Z+
 371 0024 8F01      		movw r16,r30
 372               	.LVL16:
 393:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 373               		.loc 1 393 5 is_stmt 1 view .LVU74
 393:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 374               		.loc 1 393 30 is_stmt 0 view .LVU75
 375 0026 E82F      		mov r30,r24
 376 0028 E295      		swap r30
 377 002a EF70      		andi r30,lo8(15)
 378 002c F0E0      		ldi r31,0
 379 002e 91A1      		ldd r25,Z+33
 393:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 380               		.loc 1 393 34 view .LVU76
 381 0030 8F70      		andi r24,lo8(15)
 382               	.LVL17:
 393:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 383               		.loc 1 393 34 view .LVU77
 384 0032 A701      		movw r20,r14
 385 0034 00C0      		rjmp 2f
 386               		1:
 387 0036 440F      		lsl r20
 388               		2:
 389 0038 8A95      		dec r24
 390 003a 02F4      		brpl 1b
 393:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 391               		.loc 1 393 30 view .LVU78
 392 003c 892F      		mov r24,r25
 393 003e 842B      		or r24,r20
 394 0040 81A3      		std Z+33,r24
 395               	.LVL18:
 394:quantum/matrix.c **** }
 396               		.loc 1 394 5 is_stmt 1 view .LVU79
 394:quantum/matrix.c **** }
 397               		.loc 1 394 30 is_stmt 0 view .LVU80
 398 0042 92A1      		ldd r25,Z+34
 399 0044 342F      		mov r19,r20
 400 0046 3095      		com r19
 401 0048 9323      		and r25,r19
 402 004a 92A3      		std Z+34,r25
 403               	.LVL19:
 394:quantum/matrix.c **** }
 404               		.loc 1 394 30 view .LVU81
 405               	.LBE46:
 406               	.LBE47:
 356:quantum/matrix.c **** 
 407               		.loc 1 356 5 is_stmt 1 view .LVU82
 408               	.LBB48:
 409               	.LBI48:
 410               		.file 2 "/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h"
   1:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    All rights reserved.
   5:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
   6:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
   9:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
  12:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****      distribution.
  16:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
  17:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
  21:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
  33:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
  35:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
  38:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** #  endif
  42:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
  44:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** #include <inttypes.h>
  45:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** #include <math.h>
  47:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
  48:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** /** \file */
  49:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     \code
  51:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     \endcode
  55:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
  56:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     used.
  60:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
  61:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
  70:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     routines linked into the application.
  78:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
  79:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
  83:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** */
  84:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
  85:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** #endif
  89:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
  90:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** #ifndef F_CPU
  91:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     \def F_CPU
  95:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
  97:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 103:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     integer value.
 107:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****  */
 108:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** #endif
 110:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 111:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** #endif
 114:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 115:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** #  include <math.h>
 119:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** #endif
 120:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 121:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** /**
 122:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    \ingroup util_delay
 123:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 124:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 126:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 129:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 131:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 137:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 142:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    microseconds of delay.
 146:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 147:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    respectively.
 151:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 152:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    \note
 153:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 154:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    not available to the compiler then.
 163:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 164:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****  */
 165:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** void
 166:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** {
 168:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 	double __tmp ;
 169:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 176:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 179:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 182:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 	#else
 183:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 		//round up by default
 184:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 	#endif
 186:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 187:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 189:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** #else
 190:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 		__ticks = 1;
 194:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 	{
 196:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 		while(__ticks)
 199:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 		{
 200:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 			__ticks --;
 203:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 		}
 204:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 		return;
 205:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 	}
 206:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 	else
 207:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** #endif
 210:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** }
 211:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 212:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** /**
 213:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    \ingroup util_delay
 214:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 215:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 217:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 220:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 222:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    will not be informed about this case.
 225:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 226:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 231:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    microseconds of delay.
 235:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 236:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    respectively.
 240:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 241:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    \note
 242:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 243:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    not available to the compiler then.
 252:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 253:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****  */
 254:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** void
 255:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** _delay_us(double __us)
 411               		.loc 2 255 1 view .LVU83
 412               	.LBB49:
 256:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** {
 257:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 	double __tmp ;
 413               		.loc 2 257 2 view .LVU84
 258:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 414               		.loc 2 261 2 view .LVU85
 262:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 415               		.loc 2 262 2 view .LVU86
 263:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 416               		.loc 2 263 2 view .LVU87
 264:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 265:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 268:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 271:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 	#else
 272:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 		//round up by default
 273:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 417               		.loc 2 273 3 view .LVU88
 274:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 	#endif
 275:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 276:/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 418               		.loc 2 276 2 view .LVU89
 419 004c 60EA      		ldi r22,lo8(-96)
 420 004e 6A95      	1:	dec r22
 421 0050 01F4      		brne 1b
 422               	.LVL20:
 423               		.loc 2 276 2 is_stmt 0 view .LVU90
 424               	.LBE49:
 425               	.LBE48:
 359:quantum/matrix.c ****     {
 426               		.loc 1 359 5 is_stmt 1 view .LVU91
 427               	.LBB50:
 359:quantum/matrix.c ****     {
 428               		.loc 1 359 9 view .LVU92
 359:quantum/matrix.c ****     {
 429               		.loc 1 359 32 view .LVU93
 430               	.LBB51:
 363:quantum/matrix.c **** 
 431               		.loc 1 363 9 view .LVU94
 363:quantum/matrix.c **** 
 432               		.loc 1 363 22 is_stmt 0 view .LVU95
 433 0052 2091 0000 		lds r18,matrix_debouncing
 434               	.LVL21:
 366:quantum/matrix.c ****         {
 435               		.loc 1 366 9 is_stmt 1 view .LVU96
 436 0056 C701      		movw r24,r14
 437 0058 0C2E      		mov r0,r28
 438 005a 00C0      		rjmp 2f
 439               		1:
 440 005c 880F      		lsl r24
 441               		2:
 442 005e 0A94      		dec r0
 443 0060 02F4      		brpl 1b
 366:quantum/matrix.c ****         {
 444               		.loc 1 366 12 is_stmt 0 view .LVU97
 445 0062 4C99      		sbic 0x9,4
 446 0064 00C0      		rjmp .L13
 369:quantum/matrix.c ****         }
 447               		.loc 1 369 13 is_stmt 1 view .LVU98
 369:quantum/matrix.c ****         }
 448               		.loc 1 369 39 is_stmt 0 view .LVU99
 449 0066 822B      		or r24,r18
 450               	.L21:
 374:quantum/matrix.c ****         }
 451               		.loc 1 374 39 view .LVU100
 452 0068 8093 0000 		sts matrix_debouncing,r24
 378:quantum/matrix.c ****         {
 453               		.loc 1 378 9 is_stmt 1 view .LVU101
 378:quantum/matrix.c ****         {
 454               		.loc 1 378 46 is_stmt 0 view .LVU102
 455 006c 9091 0000 		lds r25,matrix_debouncing
 456               	.LVL22:
 378:quantum/matrix.c ****         {
 457               		.loc 1 378 46 view .LVU103
 458               	.LBE51:
 459               	.LBE50:
 385:quantum/matrix.c **** 
 460               		.loc 1 385 5 is_stmt 1 view .LVU104
 461               	.LBB53:
 462               	.LBI53:
 397:quantum/matrix.c **** {
 463               		.loc 1 397 13 view .LVU105
 464               	.LBB54:
 399:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 465               		.loc 1 399 5 view .LVU106
 400:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 466               		.loc 1 400 5 view .LVU107
 400:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 467               		.loc 1 400 30 is_stmt 0 view .LVU108
 468 0070 81A1      		ldd r24,Z+33
 469 0072 8323      		and r24,r19
 470 0074 81A3      		std Z+33,r24
 401:quantum/matrix.c **** }
 471               		.loc 1 401 5 is_stmt 1 view .LVU109
 401:quantum/matrix.c **** }
 472               		.loc 1 401 30 is_stmt 0 view .LVU110
 473 0076 82A1      		ldd r24,Z+34
 474 0078 842B      		or r24,r20
 475 007a 82A3      		std Z+34,r24
 476               	.LVL23:
 401:quantum/matrix.c **** }
 477               		.loc 1 401 30 view .LVU111
 478               	.LBE54:
 479               	.LBE53:
 387:quantum/matrix.c **** }
 480               		.loc 1 387 5 is_stmt 1 view .LVU112
 387:quantum/matrix.c **** }
 481               		.loc 1 387 5 is_stmt 0 view .LVU113
 482               	.LBE56:
 483               	.LBE58:
 203:quantum/matrix.c ****                 debouncing = true;
 484               		.loc 1 203 13 is_stmt 1 view .LVU114
 203:quantum/matrix.c ****                 debouncing = true;
 485               		.loc 1 203 16 is_stmt 0 view .LVU115
 486 007c 2917      		cp r18,r25
 487 007e 01F0      		breq .L15
 488               	.LVL24:
 204:quantum/matrix.c ****                 debouncing_time = timer_read();
 489               		.loc 1 204 17 is_stmt 1 view .LVU116
 204:quantum/matrix.c ****                 debouncing_time = timer_read();
 490               		.loc 1 204 28 is_stmt 0 view .LVU117
 491 0080 D092 0000 		sts debouncing,r13
 205:quantum/matrix.c ****             }
 492               		.loc 1 205 17 is_stmt 1 view .LVU118
 205:quantum/matrix.c ****             }
 493               		.loc 1 205 35 is_stmt 0 view .LVU119
 494 0084 0E94 0000 		call timer_read
 495               	.LVL25:
 205:quantum/matrix.c ****             }
 496               		.loc 1 205 33 view .LVU120
 497 0088 9093 0000 		sts debouncing_time+1,r25
 498 008c 8093 0000 		sts debouncing_time,r24
 499               	.LVL26:
 500               	.L15:
 205:quantum/matrix.c ****             }
 501               		.loc 1 205 33 view .LVU121
 502               	.LBE41:
 200:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 503               		.loc 1 200 62 is_stmt 1 discriminator 2 view .LVU122
 200:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 504               		.loc 1 200 35 discriminator 2 view .LVU123
 505 0090 2196      		adiw r28,1
 506               	.LVL27:
 200:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 507               		.loc 1 200 5 is_stmt 0 discriminator 2 view .LVU124
 508 0092 C330      		cpi r28,3
 509 0094 D105      		cpc r29,__zero_reg__
 510 0096 01F4      		brne .L16
 511               	.LBE61:
 216:quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 512               		.loc 1 216 9 is_stmt 1 view .LVU125
 216:quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 513               		.loc 1 216 12 is_stmt 0 view .LVU126
 514 0098 8091 0000 		lds r24,debouncing
 515 009c 8823      		tst r24
 516 009e 01F0      		breq .L18
 216:quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 517               		.loc 1 216 28 discriminator 1 view .LVU127
 518 00a0 8091 0000 		lds r24,debouncing_time
 519 00a4 9091 0000 		lds r25,debouncing_time+1
 520 00a8 0E94 0000 		call timer_elapsed
 521               	.LVL28:
 216:quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 522               		.loc 1 216 24 discriminator 1 view .LVU128
 523 00ac 0697      		sbiw r24,6
 524 00ae 00F0      		brlo .L18
 525               	.LVL29:
 526               	.LBB62:
 217:quantum/matrix.c ****                 matrix[i] = matrix_debouncing[i];
 527               		.loc 1 217 33 is_stmt 1 discriminator 1 view .LVU129
 218:quantum/matrix.c ****             }
 528               		.loc 1 218 17 discriminator 1 view .LVU130
 218:quantum/matrix.c ****             }
 529               		.loc 1 218 27 is_stmt 0 discriminator 1 view .LVU131
 530 00b0 8091 0000 		lds r24,matrix_debouncing
 531 00b4 8093 0000 		sts matrix,r24
 217:quantum/matrix.c ****                 matrix[i] = matrix_debouncing[i];
 532               		.loc 1 217 50 is_stmt 1 discriminator 1 view .LVU132
 533               	.LVL30:
 217:quantum/matrix.c ****                 matrix[i] = matrix_debouncing[i];
 534               		.loc 1 217 33 discriminator 1 view .LVU133
 535               	.LBE62:
 220:quantum/matrix.c ****         }
 536               		.loc 1 220 13 discriminator 1 view .LVU134
 220:quantum/matrix.c ****         }
 537               		.loc 1 220 24 is_stmt 0 discriminator 1 view .LVU135
 538 00b8 1092 0000 		sts debouncing,__zero_reg__
 539               	.LVL31:
 540               	.L18:
 224:quantum/matrix.c ****     return 1;
 541               		.loc 1 224 5 is_stmt 1 view .LVU136
 542 00bc 0E94 0000 		call matrix_scan_quantum
 543               	.LVL32:
 225:quantum/matrix.c **** }
 544               		.loc 1 225 5 view .LVU137
 226:quantum/matrix.c **** 
 545               		.loc 1 226 1 is_stmt 0 view .LVU138
 546 00c0 81E0      		ldi r24,lo8(1)
 547               	/* epilogue start */
 548 00c2 DF91      		pop r29
 549 00c4 CF91      		pop r28
 550               	.LVL33:
 226:quantum/matrix.c **** 
 551               		.loc 1 226 1 view .LVU139
 552 00c6 1F91      		pop r17
 553 00c8 0F91      		pop r16
 554 00ca FF90      		pop r15
 555 00cc EF90      		pop r14
 556 00ce DF90      		pop r13
 557 00d0 0895      		ret
 558               	.LVL34:
 559               	.L13:
 560               	.LBB63:
 561               	.LBB60:
 562               	.LBB59:
 563               	.LBB57:
 564               	.LBB55:
 565               	.LBB52:
 374:quantum/matrix.c ****         }
 566               		.loc 1 374 13 is_stmt 1 view .LVU140
 374:quantum/matrix.c ****         }
 567               		.loc 1 374 39 is_stmt 0 view .LVU141
 568 00d2 8095      		com r24
 569 00d4 8223      		and r24,r18
 570 00d6 00C0      		rjmp .L21
 571               	.LBE52:
 572               	.LBE55:
 573               	.LBE57:
 574               	.LBE59:
 575               	.LBE60:
 576               	.LBE63:
 577               		.cfi_endproc
 578               	.LFE15:
 580               		.section	.text.matrix_is_modified,"ax",@progbits
 581               	.global	matrix_is_modified
 583               	matrix_is_modified:
 584               	.LFB16:
 229:quantum/matrix.c **** #if (DEBOUNCING_DELAY > 0)
 585               		.loc 1 229 1 is_stmt 1 view -0
 586               		.cfi_startproc
 587               	/* prologue: function */
 588               	/* frame size = 0 */
 589               	/* stack size = 0 */
 590               	.L__stack_usage = 0
 231:quantum/matrix.c **** #endif
 591               		.loc 1 231 5 view .LVU143
 231:quantum/matrix.c **** #endif
 592               		.loc 1 231 8 is_stmt 0 view .LVU144
 593 0000 9091 0000 		lds r25,debouncing
 234:quantum/matrix.c **** 
 594               		.loc 1 234 1 view .LVU145
 595 0004 81E0      		ldi r24,lo8(1)
 596 0006 8927      		eor r24,r25
 597               	/* epilogue start */
 598 0008 0895      		ret
 599               		.cfi_endproc
 600               	.LFE16:
 602               		.section	.text.matrix_is_on,"ax",@progbits
 603               	.global	matrix_is_on
 605               	matrix_is_on:
 606               	.LVL35:
 607               	.LFB17:
 238:quantum/matrix.c ****     return (matrix[row] & ((matrix_row_t)1<col));
 608               		.loc 1 238 1 is_stmt 1 view -0
 609               		.cfi_startproc
 610               	/* prologue: function */
 611               	/* frame size = 0 */
 612               	/* stack size = 0 */
 613               	.L__stack_usage = 0
 239:quantum/matrix.c **** }
 614               		.loc 1 239 5 view .LVU147
 239:quantum/matrix.c **** }
 615               		.loc 1 239 19 is_stmt 0 view .LVU148
 616 0000 E82F      		mov r30,r24
 617 0002 F0E0      		ldi r31,0
 618 0004 E050      		subi r30,lo8(-(matrix))
 619 0006 F040      		sbci r31,hi8(-(matrix))
 620 0008 8081      		ld r24,Z
 621               	.LVL36:
 239:quantum/matrix.c **** }
 622               		.loc 1 239 43 view .LVU149
 623 000a 21E0      		ldi r18,lo8(1)
 624 000c 30E0      		ldi r19,0
 625 000e 6230      		cpi r22,lo8(2)
 626 0010 00F4      		brsh .L24
 627 0012 20E0      		ldi r18,0
 628               	.L24:
 239:quantum/matrix.c **** }
 629               		.loc 1 239 25 view .LVU150
 630 0014 8223      		and r24,r18
 240:quantum/matrix.c **** 
 631               		.loc 1 240 1 view .LVU151
 632 0016 8170      		andi r24,lo8(1)
 633               	/* epilogue start */
 634 0018 0895      		ret
 635               		.cfi_endproc
 636               	.LFE17:
 638               		.section	.text.matrix_get_row,"ax",@progbits
 639               	.global	matrix_get_row
 641               	matrix_get_row:
 642               	.LVL37:
 643               	.LFB18:
 244:quantum/matrix.c ****     // Matrix mask lets you disable switches in the returned matrix data. For example, if you have 
 644               		.loc 1 244 1 is_stmt 1 view -0
 645               		.cfi_startproc
 646               	/* prologue: function */
 647               	/* frame size = 0 */
 648               	/* stack size = 0 */
 649               	.L__stack_usage = 0
 250:quantum/matrix.c **** #endif
 650               		.loc 1 250 5 view .LVU153
 250:quantum/matrix.c **** #endif
 651               		.loc 1 250 18 is_stmt 0 view .LVU154
 652 0000 E82F      		mov r30,r24
 653 0002 F0E0      		ldi r31,0
 654 0004 E050      		subi r30,lo8(-(matrix))
 655 0006 F040      		sbci r31,hi8(-(matrix))
 252:quantum/matrix.c **** 
 656               		.loc 1 252 1 view .LVU155
 657 0008 8081      		ld r24,Z
 658               	.LVL38:
 659               	/* epilogue start */
 252:quantum/matrix.c **** 
 660               		.loc 1 252 1 view .LVU156
 661 000a 0895      		ret
 662               		.cfi_endproc
 663               	.LFE18:
 665               		.section	.text.matrix_print,"ax",@progbits
 666               	.global	matrix_print
 668               	matrix_print:
 669               	.LFB19:
 255:quantum/matrix.c ****     print_matrix_header();
 670               		.loc 1 255 1 is_stmt 1 view -0
 671               		.cfi_startproc
 672               	/* prologue: function */
 673               	/* frame size = 0 */
 674               	/* stack size = 0 */
 675               	.L__stack_usage = 0
 256:quantum/matrix.c **** 
 676               		.loc 1 256 26 view .LVU158
 258:quantum/matrix.c ****         phex(row); print(": ");
 677               		.loc 1 258 5 view .LVU159
 258:quantum/matrix.c ****         phex(row); print(": ");
 678               		.loc 1 258 10 view .LVU160
 679               	.LVL39:
 258:quantum/matrix.c ****         phex(row); print(": ");
 680               		.loc 1 258 27 view .LVU161
 258:quantum/matrix.c ****         phex(row); print(": ");
 681               		.loc 1 258 27 view .LVU162
 682               	/* epilogue start */
 263:quantum/matrix.c **** 
 683               		.loc 1 263 1 is_stmt 0 view .LVU163
 684 0000 0895      		ret
 685               		.cfi_endproc
 686               	.LFE19:
 688               		.section	.text.matrix_key_count,"ax",@progbits
 689               	.global	matrix_key_count
 691               	matrix_key_count:
 692               	.LFB20:
 266:quantum/matrix.c ****     uint8_t count = 0;
 693               		.loc 1 266 1 is_stmt 1 view -0
 694               		.cfi_startproc
 695               	/* prologue: function */
 696               	/* frame size = 0 */
 697               	/* stack size = 0 */
 698               	.L__stack_usage = 0
 267:quantum/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 699               		.loc 1 267 5 view .LVU165
 700               	.LVL40:
 268:quantum/matrix.c ****         count += matrix_bitpop(i);
 701               		.loc 1 268 5 view .LVU166
 702               	.LBB64:
 268:quantum/matrix.c ****         count += matrix_bitpop(i);
 703               		.loc 1 268 10 view .LVU167
 268:quantum/matrix.c ****         count += matrix_bitpop(i);
 704               		.loc 1 268 25 view .LVU168
 269:quantum/matrix.c ****     }
 705               		.loc 1 269 9 view .LVU169
 269:quantum/matrix.c ****     }
 706               		.loc 1 269 18 is_stmt 0 view .LVU170
 707 0000 8091 0000 		lds r24,matrix
 708 0004 0C94 0000 		jmp bitpop
 709               	.LVL41:
 710               	.LBE64:
 711               		.cfi_endproc
 712               	.LFE20:
 714               		.section	.bss.matrix_debouncing,"aw",@nobits
 717               	matrix_debouncing:
 718 0000 00        		.zero	1
 719               		.section	.bss.matrix,"aw",@nobits
 722               	matrix:
 723 0000 00        		.zero	1
 724               		.section	.rodata.col_pins,"a"
 727               	col_pins:
 728 0000 9291 90   		.ascii	"\222\221\220"
 729               		.section	.bss.debouncing,"aw",@nobits
 732               	debouncing:
 733 0000 00        		.zero	1
 734               		.section	.bss.debouncing_time,"aw",@nobits
 737               	debouncing_time:
 738 0000 0000      		.zero	2
 739               		.text
 740               	.Letext0:
 741               		.file 3 "/opt/homebrew/Cellar/avr-gcc@9/9.3.0_3/avr/include/stdint.h"
 742               		.file 4 "./tmk_core/common/debug.h"
 743               		.file 5 "./tmk_core/common/matrix.h"
 744               		.file 6 "./tmk_core/common/timer.h"
 745               		.file 7 "./tmk_core/common/util.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 matrix.c
/var/folders/0z/ym_gdwfd5tg7m49f_1nfh8300000gn/T//ccn5NrIg.s:2      *ABS*:000000000000003e __SP_H__
/var/folders/0z/ym_gdwfd5tg7m49f_1nfh8300000gn/T//ccn5NrIg.s:3      *ABS*:000000000000003d __SP_L__
/var/folders/0z/ym_gdwfd5tg7m49f_1nfh8300000gn/T//ccn5NrIg.s:4      *ABS*:000000000000003f __SREG__
/var/folders/0z/ym_gdwfd5tg7m49f_1nfh8300000gn/T//ccn5NrIg.s:5      *ABS*:0000000000000000 __tmp_reg__
/var/folders/0z/ym_gdwfd5tg7m49f_1nfh8300000gn/T//ccn5NrIg.s:6      *ABS*:0000000000000001 __zero_reg__
/var/folders/0z/ym_gdwfd5tg7m49f_1nfh8300000gn/T//ccn5NrIg.s:13     .text.matrix_init_user:0000000000000000 matrix_init_user
/var/folders/0z/ym_gdwfd5tg7m49f_1nfh8300000gn/T//ccn5NrIg.s:13     .text.matrix_init_user:0000000000000000 matrix_init_user.localalias
/var/folders/0z/ym_gdwfd5tg7m49f_1nfh8300000gn/T//ccn5NrIg.s:32     .text.matrix_init_kb:0000000000000000 matrix_init_kb
/var/folders/0z/ym_gdwfd5tg7m49f_1nfh8300000gn/T//ccn5NrIg.s:49     .text.matrix_init_quantum:0000000000000000 matrix_init_quantum
/var/folders/0z/ym_gdwfd5tg7m49f_1nfh8300000gn/T//ccn5NrIg.s:66     .text.matrix_scan_user:0000000000000000 matrix_scan_user
/var/folders/0z/ym_gdwfd5tg7m49f_1nfh8300000gn/T//ccn5NrIg.s:81     .text.matrix_scan_kb:0000000000000000 matrix_scan_kb
/var/folders/0z/ym_gdwfd5tg7m49f_1nfh8300000gn/T//ccn5NrIg.s:98     .text.matrix_scan_quantum:0000000000000000 matrix_scan_quantum
/var/folders/0z/ym_gdwfd5tg7m49f_1nfh8300000gn/T//ccn5NrIg.s:115    .text.matrix_rows:0000000000000000 matrix_rows
/var/folders/0z/ym_gdwfd5tg7m49f_1nfh8300000gn/T//ccn5NrIg.s:134    .text.matrix_cols:0000000000000000 matrix_cols
/var/folders/0z/ym_gdwfd5tg7m49f_1nfh8300000gn/T//ccn5NrIg.s:153    .text.matrix_init:0000000000000000 matrix_init
/var/folders/0z/ym_gdwfd5tg7m49f_1nfh8300000gn/T//ccn5NrIg.s:727    .rodata.col_pins:0000000000000000 col_pins
/var/folders/0z/ym_gdwfd5tg7m49f_1nfh8300000gn/T//ccn5NrIg.s:722    .bss.matrix:0000000000000000 matrix
/var/folders/0z/ym_gdwfd5tg7m49f_1nfh8300000gn/T//ccn5NrIg.s:717    .bss.matrix_debouncing:0000000000000000 matrix_debouncing
/var/folders/0z/ym_gdwfd5tg7m49f_1nfh8300000gn/T//ccn5NrIg.s:290    .text.matrix_scan:0000000000000000 matrix_scan
/var/folders/0z/ym_gdwfd5tg7m49f_1nfh8300000gn/T//ccn5NrIg.s:732    .bss.debouncing:0000000000000000 debouncing
/var/folders/0z/ym_gdwfd5tg7m49f_1nfh8300000gn/T//ccn5NrIg.s:737    .bss.debouncing_time:0000000000000000 debouncing_time
/var/folders/0z/ym_gdwfd5tg7m49f_1nfh8300000gn/T//ccn5NrIg.s:583    .text.matrix_is_modified:0000000000000000 matrix_is_modified
/var/folders/0z/ym_gdwfd5tg7m49f_1nfh8300000gn/T//ccn5NrIg.s:605    .text.matrix_is_on:0000000000000000 matrix_is_on
/var/folders/0z/ym_gdwfd5tg7m49f_1nfh8300000gn/T//ccn5NrIg.s:641    .text.matrix_get_row:0000000000000000 matrix_get_row
/var/folders/0z/ym_gdwfd5tg7m49f_1nfh8300000gn/T//ccn5NrIg.s:668    .text.matrix_print:0000000000000000 matrix_print
/var/folders/0z/ym_gdwfd5tg7m49f_1nfh8300000gn/T//ccn5NrIg.s:691    .text.matrix_key_count:0000000000000000 matrix_key_count

UNDEFINED SYMBOLS
timer_read
timer_elapsed
bitpop
__do_copy_data
__do_clear_bss
